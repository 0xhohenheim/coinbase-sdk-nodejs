/* tslint:disable */
/* eslint-disable */
/**
 * Coinbase Platform API
 * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.
 *
 * The version of the OpenAPI document: 0.0.1-alpha
 * Contact: yuga.cohler@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from "./base";

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   * The ID of the wallet that owns the address
   * @type {string}
   * @memberof Address
   */
  wallet_id: string;
  /**
   * The ID of the blockchain network
   * @type {string}
   * @memberof Address
   */
  network_id: string;
  /**
   * The public key from which the address is derived.
   * @type {string}
   * @memberof Address
   */
  public_key: string;
  /**
   * The onchain address derived on the server-side.
   * @type {string}
   * @memberof Address
   */
  address_id: string;
}
/**
 *
 * @export
 * @interface AddressBalanceList
 */
export interface AddressBalanceList {
  /**
   *
   * @type {Array<Balance>}
   * @memberof AddressBalanceList
   */
  data: Array<Balance>;
  /**
   * True if this list has another page of items after this one that can be fetched.
   * @type {boolean}
   * @memberof AddressBalanceList
   */
  has_more: boolean;
  /**
   * The page token to be used to fetch the next page.
   * @type {string}
   * @memberof AddressBalanceList
   */
  next_page: string;
  /**
   * The total number of balances for the wallet.
   * @type {number}
   * @memberof AddressBalanceList
   */
  total_count: number;
}
/**
 *
 * @export
 * @interface AddressList
 */
export interface AddressList {
  /**
   *
   * @type {Array<Address>}
   * @memberof AddressList
   */
  data: Array<Address>;
  /**
   * True if this list has another page of items after this one that can be fetched.
   * @type {boolean}
   * @memberof AddressList
   */
  has_more: boolean;
  /**
   * The page token to be used to fetch the next page.
   * @type {string}
   * @memberof AddressList
   */
  next_page: string;
  /**
   * The total number of addresses for the wallet.
   * @type {number}
   * @memberof AddressList
   */
  total_count: number;
}
/**
 * An asset onchain scoped to a particular network, e.g. ETH on base-sepolia, or the USDC ERC20 Token on ethereum-mainnet.
 * @export
 * @interface Asset
 */
export interface Asset {
  /**
   * The ID of the blockchain network
   * @type {string}
   * @memberof Asset
   */
  network_id: string;
  /**
   * The ID for the asset on the network
   * @type {string}
   * @memberof Asset
   */
  asset_id: string;
  /**
   * The number of decimals the asset supports. This is used to convert from atomic units to base units.
   * @type {number}
   * @memberof Asset
   */
  decimals?: number;
  /**
   * The optional contract address for the asset. This will be specified for smart contract-based assets, for example ERC20s.
   * @type {string}
   * @memberof Asset
   */
  contract_address?: string;
}
/**
 * The balance of an asset onchain
 * @export
 * @interface Balance
 */
export interface Balance {
  /**
   * The amount in the atomic units of the asset
   * @type {string}
   * @memberof Balance
   */
  amount: string;
  /**
   *
   * @type {Asset}
   * @memberof Balance
   */
  asset: Asset;
}
/**
 *
 * @export
 * @interface BroadcastTransferRequest
 */
export interface BroadcastTransferRequest {
  /**
   * The hex-encoded signed payload of the transfer
   * @type {string}
   * @memberof BroadcastTransferRequest
   */
  signed_payload: string;
}
/**
 *
 * @export
 * @interface CreateAddressRequest
 */
export interface CreateAddressRequest {
  /**
   * The public key from which the address will be derived.
   * @type {string}
   * @memberof CreateAddressRequest
   */
  public_key: string;
  /**
   * An attestation signed by the private key that is associated with the wallet. The attestation will be a hex-encoded signature of a json payload with fields `wallet_id` and `public_key`, signed by the private key associated with the public_key set in the request.
   * @type {string}
   * @memberof CreateAddressRequest
   */
  attestation: string;
}
/**
 *
 * @export
 * @interface CreateTransferRequest
 */
export interface CreateTransferRequest {
  /**
   * The amount to transfer
   * @type {string}
   * @memberof CreateTransferRequest
   */
  amount: string;
  /**
   * The ID of the blockchain network
   * @type {string}
   * @memberof CreateTransferRequest
   */
  network_id: string;
  /**
   * The ID of the asset to transfer
   * @type {string}
   * @memberof CreateTransferRequest
   */
  asset_id: string;
  /**
   * The destination address
   * @type {string}
   * @memberof CreateTransferRequest
   */
  destination: string;
}
/**
 *
 * @export
 * @interface CreateWalletRequest
 */
export interface CreateWalletRequest {
  /**
   *
   * @type {Wallet}
   * @memberof CreateWalletRequest
   */
  wallet: Wallet;
}
/**
 *
 * @export
 * @interface FaucetTransaction
 */
export interface FaucetTransaction {
  /**
   * The transaction hash of the transaction the faucet created.
   * @type {string}
   * @memberof FaucetTransaction
   */
  transaction_hash: string;
}
/**
 * An error response from the Coinbase Developer Platform API
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * A short string representing the reported error. Can be use to handle errors programmatically.
   * @type {string}
   * @memberof ModelError
   */
  code: string;
  /**
   * A human-readable message providing more details about the error.
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 * A transfer of an asset from one address to another
 * @export
 * @interface Transfer
 */
export interface Transfer {
  /**
   * The ID of the blockchain network
   * @type {string}
   * @memberof Transfer
   */
  network_id: string;
  /**
   * The ID of the wallet that owns the from address
   * @type {string}
   * @memberof Transfer
   */
  wallet_id: string;
  /**
   * The onchain address of the sender
   * @type {string}
   * @memberof Transfer
   */
  address_id: string;
  /**
   * The onchain address of the recipient
   * @type {string}
   * @memberof Transfer
   */
  destination: string;
  /**
   * The amount in the atomic units of the asset
   * @type {string}
   * @memberof Transfer
   */
  amount: string;
  /**
   * The ID of the asset being transferred
   * @type {string}
   * @memberof Transfer
   */
  asset_id: string;
  /**
   * The ID of the transfer
   * @type {string}
   * @memberof Transfer
   */
  transfer_id: string;
  /**
   * The unsigned payload of the transfer. This is the payload that needs to be signed by the sender.
   * @type {string}
   * @memberof Transfer
   */
  unsigned_payload: string;
  /**
   * The signed payload of the transfer. This is the payload that has been signed by the sender.
   * @type {string}
   * @memberof Transfer
   */
  signed_payload?: string;
  /**
   * The hash of the transfer transaction
   * @type {string}
   * @memberof Transfer
   */
  transaction_hash?: string;
  /**
   * The status of the transfer
   * @type {string}
   * @memberof Transfer
   */
  status: TransferStatusEnum;
}

export const TransferStatusEnum = {
  Pending: "pending",
  Broadcast: "broadcast",
  Complete: "complete",
  Failed: "failed",
} as const;

export type TransferStatusEnum = (typeof TransferStatusEnum)[keyof typeof TransferStatusEnum];

/**
 *
 * @export
 * @interface TransferList
 */
export interface TransferList {
  /**
   *
   * @type {Array<Transfer>}
   * @memberof TransferList
   */
  data: Array<Transfer>;
  /**
   * True if this list has another page of items after this one that can be fetched.
   * @type {boolean}
   * @memberof TransferList
   */
  has_more: boolean;
  /**
   * The page token to be used to fetch the next page.
   * @type {string}
   * @memberof TransferList
   */
  next_page: string;
  /**
   * The total number of transfers for the address in the wallet.
   * @type {number}
   * @memberof TransferList
   */
  total_count: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * The ID of the user
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  display_name?: string;
}
/**
 *
 * @export
 * @interface Wallet
 */
export interface Wallet {
  /**
   * The server-assigned ID for the wallet.
   * @type {string}
   * @memberof Wallet
   */
  id?: string;
  /**
   * The ID of the blockchain network
   * @type {string}
   * @memberof Wallet
   */
  network_id: string;
  /**
   *
   * @type {Address}
   * @memberof Wallet
   */
  default_address?: Address;
}
/**
 * Paginated list of wallets
 * @export
 * @interface WalletList
 */
export interface WalletList {
  /**
   *
   * @type {Array<Wallet>}
   * @memberof WalletList
   */
  data: Array<Wallet>;
  /**
   * True if this list has another page of items after this one that can be fetched.
   * @type {boolean}
   * @memberof WalletList
   */
  has_more: boolean;
  /**
   * The page token to be used to fetch the next page.
   * @type {string}
   * @memberof WalletList
   */
  next_page: string;
  /**
   * The total number of wallets
   * @type {number}
   * @memberof WalletList
   */
  total_count: number;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress: async (
      walletId: string,
      createAddressRequest?: CreateAddressRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("createAddress", "walletId", walletId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses`.replace(
        `{${"wallet_id"}}`,
        encodeURIComponent(String(walletId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAddressRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress: async (
      walletId: string,
      addressId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("getAddress", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("getAddress", "addressId", addressId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressBalance: async (
      walletId: string,
      addressId: string,
      assetId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("getAddressBalance", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("getAddressBalance", "addressId", addressId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getAddressBalance", "assetId", assetId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressBalances: async (
      walletId: string,
      addressId: string,
      page?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("listAddressBalances", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("listAddressBalances", "addressId", addressId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses: async (
      walletId: string,
      limit?: number,
      page?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("listAddresses", "walletId", walletId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses`.replace(
        `{${"wallet_id"}}`,
        encodeURIComponent(String(walletId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFaucetFunds: async (
      walletId: string,
      addressId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("requestFaucetFunds", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("requestFaucetFunds", "addressId", addressId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAddress(
      walletId: string,
      createAddressRequest?: CreateAddressRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(
        walletId,
        createAddressRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AddressesApi.createAddress"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddress(
      walletId: string,
      addressId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(
        walletId,
        addressId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AddressesApi.getAddress"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddressBalance(
      walletId: string,
      addressId: string,
      assetId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(
        walletId,
        addressId,
        assetId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AddressesApi.getAddressBalance"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAddressBalances(
      walletId: string,
      addressId: string,
      page?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(
        walletId,
        addressId,
        page,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AddressesApi.listAddressBalances"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAddresses(
      walletId: string,
      limit?: number,
      page?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(
        walletId,
        limit,
        page,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AddressesApi.listAddresses"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestFaucetFunds(
      walletId: string,
      addressId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(
        walletId,
        addressId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AddressesApi.requestFaucetFunds"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AddressesApiFp(configuration);
  return {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress(
      walletId: string,
      createAddressRequest?: CreateAddressRequest,
      options?: any,
    ): AxiosPromise<Address> {
      return localVarFp
        .createAddress(walletId, createAddressRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(walletId: string, addressId: string, options?: any): AxiosPromise<Address> {
      return localVarFp
        .getAddress(walletId, addressId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressBalance(
      walletId: string,
      addressId: string,
      assetId: string,
      options?: any,
    ): AxiosPromise<Balance> {
      return localVarFp
        .getAddressBalance(walletId, addressId, assetId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressBalances(
      walletId: string,
      addressId: string,
      page?: string,
      options?: any,
    ): AxiosPromise<AddressBalanceList> {
      return localVarFp
        .listAddressBalances(walletId, addressId, page, options)
        .then(request => request(axios, basePath));
    },
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(
      walletId: string,
      limit?: number,
      page?: string,
      options?: any,
    ): AxiosPromise<AddressList> {
      return localVarFp
        .listAddresses(walletId, limit, page, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFaucetFunds(
      walletId: string,
      addressId: string,
      options?: any,
    ): AxiosPromise<FaucetTransaction> {
      return localVarFp
        .requestFaucetFunds(walletId, addressId, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
  /**
   * Create a new address scoped to the wallet.
   * @summary Create a new address
   * @param {string} walletId The ID of the wallet to create the address in.
   * @param {CreateAddressRequest} [createAddressRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public createAddress(
    walletId: string,
    createAddressRequest?: CreateAddressRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AddressesApiFp(this.configuration)
      .createAddress(walletId, createAddressRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get address
   * @summary Get address by onchain address
   * @param {string} walletId The ID of the wallet the address belongs to.
   * @param {string} addressId The onchain address of the address that is being fetched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .getAddress(walletId, addressId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get address balance
   * @summary Get address balance for asset
   * @param {string} walletId The ID of the wallet to fetch the balance for
   * @param {string} addressId The onchain address of the address that is being fetched.
   * @param {string} assetId The symbol of the asset to fetch the balance for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public getAddressBalance(
    walletId: string,
    addressId: string,
    assetId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AddressesApiFp(this.configuration)
      .getAddressBalance(walletId, addressId, assetId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get address balances
   * @summary Get all balances for address
   * @param {string} walletId The ID of the wallet to fetch the balances for
   * @param {string} addressId The onchain address of the address that is being fetched.
   * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public listAddressBalances(
    walletId: string,
    addressId: string,
    page?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AddressesApiFp(this.configuration)
      .listAddressBalances(walletId, addressId, page, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * List addresses in the wallet.
   * @summary List addresses in a wallet.
   * @param {string} walletId The ID of the wallet whose addresses to fetch
   * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
   * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public listAddresses(
    walletId: string,
    limit?: number,
    page?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AddressesApiFp(this.configuration)
      .listAddresses(walletId, limit, page, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Request faucet funds to be sent to onchain address.
   * @summary Request faucet funds for onchain address.
   * @param {string} walletId The ID of the wallet the address belongs to.
   * @param {string} addressId The onchain address of the address that is being fetched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public requestFaucetFunds(walletId: string, addressId: string, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .requestFaucetFunds(walletId, addressId, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTransfer: async (
      walletId: string,
      addressId: string,
      transferId: string,
      broadcastTransferRequest: BroadcastTransferRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("broadcastTransfer", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("broadcastTransfer", "addressId", addressId);
      // verify required parameter 'transferId' is not null or undefined
      assertParamExists("broadcastTransfer", "transferId", transferId);
      // verify required parameter 'broadcastTransferRequest' is not null or undefined
      assertParamExists("broadcastTransfer", "broadcastTransferRequest", broadcastTransferRequest);
      const localVarPath =
        `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`
          .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
          .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
          .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        broadcastTransferRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer: async (
      walletId: string,
      addressId: string,
      createTransferRequest: CreateTransferRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("createTransfer", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("createTransfer", "addressId", addressId);
      // verify required parameter 'createTransferRequest' is not null or undefined
      assertParamExists("createTransfer", "createTransferRequest", createTransferRequest);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTransferRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer: async (
      walletId: string,
      addressId: string,
      transferId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("getTransfer", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("getTransfer", "addressId", addressId);
      // verify required parameter 'transferId' is not null or undefined
      assertParamExists("getTransfer", "transferId", transferId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
        .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers: async (
      walletId: string,
      addressId: string,
      limit?: number,
      page?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("listTransfers", "walletId", walletId);
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists("listTransfers", "addressId", addressId);
      const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration);
  return {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async broadcastTransfer(
      walletId: string,
      addressId: string,
      transferId: string,
      broadcastTransferRequest: BroadcastTransferRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(
        walletId,
        addressId,
        transferId,
        broadcastTransferRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransfersApi.broadcastTransfer"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTransfer(
      walletId: string,
      addressId: string,
      createTransferRequest: CreateTransferRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(
        walletId,
        addressId,
        createTransferRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransfersApi.createTransfer"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransfer(
      walletId: string,
      addressId: string,
      transferId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(
        walletId,
        addressId,
        transferId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransfersApi.getTransfer"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransfers(
      walletId: string,
      addressId: string,
      limit?: number,
      page?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(
        walletId,
        addressId,
        limit,
        page,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransfersApi.listTransfers"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TransfersApiFp(configuration);
  return {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTransfer(
      walletId: string,
      addressId: string,
      transferId: string,
      broadcastTransferRequest: BroadcastTransferRequest,
      options?: any,
    ): AxiosPromise<Transfer> {
      return localVarFp
        .broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(
      walletId: string,
      addressId: string,
      createTransferRequest: CreateTransferRequest,
      options?: any,
    ): AxiosPromise<Transfer> {
      return localVarFp
        .createTransfer(walletId, addressId, createTransferRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer(
      walletId: string,
      addressId: string,
      transferId: string,
      options?: any,
    ): AxiosPromise<Transfer> {
      return localVarFp
        .getTransfer(walletId, addressId, transferId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers(
      walletId: string,
      addressId: string,
      limit?: number,
      page?: string,
      options?: any,
    ): AxiosPromise<TransferList> {
      return localVarFp
        .listTransfers(walletId, addressId, limit, page, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
  /**
   * Broadcast a transfer
   * @summary Broadcast a transfer
   * @param {string} walletId The ID of the wallet the address belongs to
   * @param {string} addressId The ID of the address the transfer belongs to
   * @param {string} transferId The ID of the transfer to broadcast
   * @param {BroadcastTransferRequest} broadcastTransferRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransfersApi
   */
  public broadcastTransfer(
    walletId: string,
    addressId: string,
    transferId: string,
    broadcastTransferRequest: BroadcastTransferRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return TransfersApiFp(this.configuration)
      .broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Create a new transfer
   * @summary Create a new transfer for an address
   * @param {string} walletId The ID of the wallet the source address belongs to
   * @param {string} addressId The ID of the address to transfer from
   * @param {CreateTransferRequest} createTransferRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransfersApi
   */
  public createTransfer(
    walletId: string,
    addressId: string,
    createTransferRequest: CreateTransferRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return TransfersApiFp(this.configuration)
      .createTransfer(walletId, addressId, createTransferRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get a transfer by ID
   * @summary Get a transfer by ID
   * @param {string} walletId The ID of the wallet the address belongs to
   * @param {string} addressId The ID of the address the transfer belongs to
   * @param {string} transferId The ID of the transfer to fetch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransfersApi
   */
  public getTransfer(
    walletId: string,
    addressId: string,
    transferId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return TransfersApiFp(this.configuration)
      .getTransfer(walletId, addressId, transferId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * List transfers for an address.
   * @summary List transfers for an address.
   * @param {string} walletId The ID of the wallet the address belongs to
   * @param {string} addressId The ID of the address to list transfers for
   * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
   * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransfersApi
   */
  public listTransfers(
    walletId: string,
    addressId: string,
    limit?: number,
    page?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return TransfersApiFp(this.configuration)
      .listTransfers(walletId, addressId, limit, page, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUser(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getCurrentUser"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): AxiosPromise<User> {
      return localVarFp.getCurrentUser(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Get current user
   * @summary Get current user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUser(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getCurrentUser(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet: async (
      createWalletRequest?: CreateWalletRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/wallets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createWalletRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet: async (
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("getWallet", "walletId", walletId);
      const localVarPath = `/v1/wallets/{wallet_id}`.replace(
        `{${"wallet_id"}}`,
        encodeURIComponent(String(walletId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance: async (
      walletId: string,
      assetId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("getWalletBalance", "walletId", walletId);
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("getWalletBalance", "assetId", assetId);
      const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`
        .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
        .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletBalances: async (
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists("listWalletBalances", "walletId", walletId);
      const localVarPath = `/v1/wallets/{wallet_id}/balances`.replace(
        `{${"wallet_id"}}`,
        encodeURIComponent(String(walletId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets: async (
      limit?: number,
      page?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/wallets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWallet(
      createWalletRequest?: CreateWalletRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(
        createWalletRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WalletsApi.createWallet"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WalletsApi.getWallet"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWalletBalance(
      walletId: string,
      assetId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(
        walletId,
        assetId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WalletsApi.getWalletBalance"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWalletBalances(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(
        walletId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WalletsApi.listWalletBalances"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWallets(
      limit?: number,
      page?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WalletsApi.listWallets"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WalletsApiFp(configuration);
  return {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: any): AxiosPromise<Wallet> {
      return localVarFp
        .createWallet(createWalletRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(walletId: string, options?: any): AxiosPromise<Wallet> {
      return localVarFp.getWallet(walletId, options).then(request => request(axios, basePath));
    },
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance(walletId: string, assetId: string, options?: any): AxiosPromise<Balance> {
      return localVarFp
        .getWalletBalance(walletId, assetId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletBalances(walletId: string, options?: any): AxiosPromise<AddressBalanceList> {
      return localVarFp
        .listWalletBalances(walletId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(limit?: number, page?: string, options?: any): AxiosPromise<WalletList> {
      return localVarFp.listWallets(limit, page, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
  /**
   * Create a new wallet scoped to the user.
   * @summary Create a new wallet
   * @param {CreateWalletRequest} [createWalletRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig) {
    return WalletsApiFp(this.configuration)
      .createWallet(createWalletRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get wallet
   * @summary Get wallet by ID
   * @param {string} walletId The ID of the wallet to fetch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public getWallet(walletId: string, options?: RawAxiosRequestConfig) {
    return WalletsApiFp(this.configuration)
      .getWallet(walletId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the aggregated balance of an asset across all of the addresses in the wallet.
   * @summary Get the balance of an asset in the wallet
   * @param {string} walletId The ID of the wallet to fetch the balance for
   * @param {string} assetId The symbol of the asset to fetch the balance for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig) {
    return WalletsApiFp(this.configuration)
      .getWalletBalance(walletId, assetId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * List the balances of all of the addresses in the wallet aggregated by asset.
   * @summary List wallet balances
   * @param {string} walletId The ID of the wallet to fetch the balances for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public listWalletBalances(walletId: string, options?: RawAxiosRequestConfig) {
    return WalletsApiFp(this.configuration)
      .listWalletBalances(walletId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * List wallets belonging to the user.
   * @summary List wallets
   * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
   * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletsApi
   */
  public listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig) {
    return WalletsApiFp(this.configuration)
      .listWallets(limit, page, options)
      .then(request => request(this.axios, this.basePath));
  }
}
